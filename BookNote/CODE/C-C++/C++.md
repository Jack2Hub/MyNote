


# C
## 指针

# C++
## 重载
- 重载函数：参数 **个数、类型、实现** 都可以不一样
- 不能只有函数类型不同，而参数类型个数相同
    ``` C
    int f(int) / float f(int) / double f(int)
    ```

## 函数中使用默认参数
- 形参赋值操作方向为 **从左往右**
- 传参时赋值可以覆盖默认参数
- 函数的声明和定义都设置了默认参数，**编译系统会以声明时指定的默认参数为准**(建议设置一致)

## 函数模版 Template
- 要求：参数个数、函数实现相同，参数类型不同： template <typename T>
- 类型参数可以不止一个： template <typename T1, typename T2>

## 引用
``` C
int &b = a;
```
- **&** 在这里是 **引用声明符**，并不代表地址
- 此时b就是a，占用内存的同一个存储单元，可以理解为：**使变量b具有变量a的地址**
- C++ 中使用引用来作为函数参数
  - 指针传参可以实现将形参变量的值传回来，但是在概念上绕了一圈
- **声明一个引用类型变量，必须同时初始化**
  - 在函数参数中使用 **引用变量**，因为引用变量不是一个独立的变量，它实际就是实参，所以他不占用内存单元
  - 而且使用上相对指针传参更加直观、易读
  ``` C
  void test(Time&);     //声明
  void test(Time &t);   //定义
  ```

## 面向对象
### 类的声明与定义
- 类是对象的抽象，对象是类的具体实例
- 类是抽象的，不占用内存；对象是具体的，需要占用存储空间
- **在类的定义中，如果不指定 *成员访问限定符*：private或public，缺省是private**
  - 成员访问限定符：protected，不能被类外访问，但能被 **派生类的成员函数** 访问
  - 用 **struct** 声明的类，成员特性默认是public的
- **类class 和 结构体struct 的区别 （在C++中）**
  - [C结构体、C++结构体、C++类的区别](https://www.cnblogs.com/cthon/p/9170596.html)
  - 概念：class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到。
  - 类型：struct是值类型，class是引用类型，因此它们具有所有值类型和引用类型之间的差异。
  ``` c++
    static void Main(string[] args)
    {
        //普通变量是值类型，赋值操作时会保存两份
        //编译器会先复制strA的值，然后赋给strB，会在内存的两个地方储存值100
        int strA = 100;
        int strB = strA;

        //类是引用类型
        //赋值操作完成后，两个变量都指向同一内存地址
        MyVector vA = new MyVector();
        MyVector vB = vA;
        vA.Value = 100;
        //由于vA和vB指向同一内存地址，所以vB.Value的值也为100 
        Console.WriteLine(vA.Value + "  等于  " + vB.Value);
        vB.Value = 200;
        //同理vA.Value =vB.Value
        Console.WriteLine(vA.Value + "  等于  " + vB.Value);

        //结构体是值类型。
        //赋值操作完成后，两个结构中的结构信息一致
        //注意仅仅是"结构中的信息"一致。
        MyStruct structA = new MyStruct();
        MyStruct structB = structA; 
        structA.Value = 100;
        structB.Value = 200;
        //同理vA.Value != vB.Value
        Console.WriteLine(structA.Value + "  不等于  " + structB.Value);
        Console.Read();
    }

    private class MyVector
    {
        public int Value { get; set; }
    }

    private struct MyStruct
    {
        public int Value;
    }
  ```
  - 效率：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑。
  - 关系：struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段。

#### 类的成员函数
- 私有成员函数只能被本类中的其他成员函数调用，而不能被类外调用
- 成员函数可以访问本类中任何成员private/public，可以引用在本作用域内有效的数据
- inline成员函数
  - 在类体内定义的成员函数默认是inline，无需显示声明
  - 在类体外定义的成员函数则不是，若要指定为inline函数需要显示声明
  - **在类外定义inline成员函数时，需要将类定义和成员函数定义放在同一个源文件（.c/.h）**
    - 否则会编译不过
    - 软件执行效率提高，但是不利于软件工程的信息隐蔽等问题
    - 建议仅当 类外定义的成员函数规模小调用频率高时，才设置为inline
- 定义对象时，每个对象占用的存储空间只是该对象的数据部分，不包括成员函数代码所占用的存储空间，**函数代码是存储在对象空间之外的**
  - 这个储存方式跟 **inline** 是两回事

#### 对象成员的引用
- 访问对象成员的方法
  - 通过对象名和成员运算符访问对象中的成员
  - 通过指向对象的指针访问对象中的成员
    ``` C
    Time t, *p;
    p = &t;
    (*p).xxx == p->xxx == t.xxx
    ```
  - 通过对象的引用变量访问对象中的成员
    ``` C
    Time t1;
    Time &t2 = t1;
    t2.xxx == t1.xxx
    ```

#### 类的封装性和信息隐蔽
- C语言中一般习惯将声明全部集中写在模块开头，但是在C++中不提倡这种做法：在C++中，声明是作为语句处理的，可以出现在程序的任何位置；用到的时候再生明反而会使程序更加清晰易读

### 构造函数
- 构造函数是一种特殊的 **成员函数**，创建对象时自动执行，不需要用户来调用
- **必须与类名同名**
- 不具有任何类型、不返回任何值
- 一般声明为public
- 构造函数可以包含初始化成员变量外的其他操作(cout等)，但一般不提倡
- **若用户自己没定义构造函数，C++系统会自动生成一个空的构造函数，内部不执行任何操作**

#### 构造函数 初始化方式
- 带参数：实现不同对象的不同初始化
``` C++
构造函数名(类型1 形参1, 类型2 形参2, ...)
定义对象的一般格式如下：
类名 对象名(实参1, 实参2, ...)
```

- 参数初始化列表
``` C++
    Box::Box(int h, int w, int l):height(h), weight(w), length(l){}
```

- **构造函数也可以重载，也可以使用默认参数**
- 定义对象时不需要给出实参的构造函数，视为 **默认构造函数**
  - 一个类中只能有一个 默认构造函数
  ``` C++
  Box();
  Box(int h=10, int w=10, int l=10); //全部参数都有默认参数，即定义时可不指定实参
  //类中这么写两个构造函数是不行的，因为定义对象时 Box box1，编译系统无法判断使用哪个构造函数
  ```

### 析构函数
- 析构函数不返回任何值，没有函数类型，也没有函数参数，所以不能重载
- 一个类可以有多个构造函数，但只能有一个析构函数
- 同样，没有定义析构函数的话系统会自动生成一个空的
- **调用构造函数和析构函数的顺序**，先构造的后析构，类似栈，先入后出


#### 对象数组
- 如何在定义时构造函数初始化
  - 只定义对象数组
  ``` C++
  Student stud[50];
  ```
  - 构造函数只有一个参数
  ``` C++
  Student stud[3] = {10, 11, 12};
  ```
  - 构造函数有多个参数
  ``` C++
  Student stud[3] = {
      Student(10, 10, 10),
      Student(11, 11, 11),
      Student(12, 12, 12),
  }
  ```

#### 对象指针
- 指向对象的指针
- 指向对象成员的指针
  - 指向对象 **数据成员** 的指针
  ``` C++
  Student stud;
  int * p;
  p = &stud.num; // &(stud.num)
  ```
  - 指向对象 **成员函数** 的指针: *与普通函数指针不同*
    - 定义的指针变量必须与指向的对象属于同一个类
    ```C++
    数据类型名 (类名:: * 指针变量名)(参数列表)
    Time t1;
    void (Time:: * p)();
    p = &Time::get_time;
    (t1.*p)();  //t1.get_time()
    //成员函数不是存放在对象的空间中，而是存放在对象外的空间中。 如果存在多个同类的对象，他们使用同一个函数代码段。因此赋值给p的应是这个公有的函数代码段的入口地址
    ```

#### this指针
> 每一个成员函数都包含一个特殊的指针，这个指针的名字是固定的，成为 **this** 。他是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的 **起始地址**。  
``` C++
int Box::volume()
{return height*width*length;}
//C++编译系统会处理为
int Box::volume(Box * this)
{return (this->height)*(this->width)*(this->length);}

//即在成员函数的形参列表中增加一个this指针。在调用该成员函数时，实际上是这么调用的
Box a;
a.vlome(&a);
```
- `* this` 表示被调用的成员函数所在的对象，`* this`就是this指针指向的对象


### 公用数据保护
> 使数据能在一定范围内共享，又要保证它不被任意修改，此时选择使用const

#### 常对象
- 定义常对象时，必须要有初始值
```C++
//以下两种均可
Time const t1(10, 10, 10);
const Time t1(10, 10, 10);
```
- 定义为常对象，则对象中的所有成员变量均 **不可修改**
- 定义为常对象，则不能调用该对象的 **非const型的成员函数**(除构造/析构函数)
```C++
const Time t1(10, 10, 10);
t1.get_time(); 
//这样是非法的，因为不知道该成员函数是否会修改成员变量，这是不允许的，编译系统会报错
//将get_time成员函数声明为const类型即可: **void get_time() const**
//常成员函数可以访问常对象中的成员变量，但是不能更改
```
- ANSI C++ 考虑实际编程的需要，使用 **mutable** 声明成员变量，就可以使用常成员函数去修改该变量的值
``` C++
mutable int count;
```

#### 常对象成员
- 常数据成员
  - **常对象的数据成员都是常数据成员**
  - 只能通过构造函数的 **参数初始化列表** 进行初始化
  ``` C++
  //这种是非法的，因为常数据成员是不能被赋值的
  Time::Time(int h)
  {
      hour = h;
  }

  //构造函数在类外定义时，应写成下列形式
  Time::Time(int h):hour(h){}; //通过参数初始化列表初始化常数据成员
  ```
- 常成员函数
  - 定义 `void get_time() const;`  
  - **常成员函数不能调用另外一个非常成员函数**
  - **非常成员函数可以调用常成员函数**
  - **常成员函数可以调用常成员函数**
    |数据成员|非const成员函数|const成员函数|
    |:-|:-|:-|
    |非const数据成员|可引用，可修改|可引用，不可修改|
    |const数据成员|可引用，不可修改|可引用，不可修改|
    |const对象的数据成员|**不允许**|可引用，不可修改|

### 对象的赋值和复制
#### 对象的赋值
- 对象的赋值实际上是只有对象数据成员的赋值，而不对成员函数赋值
- 数据成员是占据实际存储空间的，而不同对象的成员函数实际上是同一个函数代码段，不需要也不允许赋值
- **类的数据成员中不能包括动态分配的数据**，否则在赋值时可能出现严重后果

#### 对象的复制
- 需求：用到完全相同的多个对象
``` C++
类名 对象2(对象1)
Box b2(b1); //此时会调用一个特殊的构造函数---复制构造函数(copy constructor)
//复制构造函数如下：
Box::Box(const Box &b)
{
    height = b.height;
    width = b.width;
    length = b.length;
}

//也可以使用赋值符号“=”来复制对象
Box box2 = box1;
```

### 静态成员
#### 静态数据成员
``` C++
class Box{
public:
    int volume();
private:
    static int height;
    int width;
    int length;
}
```
- 静态数据成员的值对所有对象都是一样，即可以当作共享变量
  - **全局变量破坏了封装的原则，不符合面向对象的概念**
  - 声明类未声明对象时，**静态数据成员**因不属于任何一个对象，故也为其分配空间，它此时可以被引用
    - 静态数据成员是在所有对象之外单独开辟空间
  - 静态数据成员不随对象的建立而分配空间，不随对象的撤销而释放
    - 它是在程序编译时就分配了空间，在程序结束时才释放
  - 静态数据成员可以初始化，但只能在类体外进行初始化
    - 未初始化的话，编译系统自动赋值 **0**
  ``` C++
  int Box::height = 10;
  // 不必加static 关键字

  // Box(int h, int w, int l):height(h){};
  // 不能用初始化列表去初始化静态数据成员 ！！！
  ```
  - 静态数据成员可以通过对象名引用，也可直接使用类名来引用
    - 若静态数据成员是 **私有private** 时，则不能直接被引用，必须通过成员函数来引用
  ``` C++
  cout << a.height << endl;
  cout << Box::height << endl;
  ```

#### 静态成员函数
- 静态成员函数的存储方式同静态数据成员
  - 静态成员函数没有 this 指针，非**则有
    - 因此静态成员函数不能访问本类中的 **非静态成员**，但可以直接引用静态成员，因为同属于一个类
    ``` C++
    //函数体
    cout << height << endl;
    cout << width << endl;   // !!! 错误，不可访问类中的 非静态成员
    cout << a.width << endl; // 除非通过对象名a引用，前提a作用域生效
    ```
- 静态成员函数作用
  - 规范化：专门处理静态数据成员
  - 可在未实例化任何对象时就调用，**提高效率，不需要去初始化一个实例**


