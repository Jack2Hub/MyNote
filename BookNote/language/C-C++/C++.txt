


# C
## 指针

# C++
## 重载
- 重载函数：参数 **个数、类型、实现** 都可以不一样
- 不能只有函数类型不同，而参数类型个数相同
    ``` C
    int f(int) / float f(int) / double f(int)
    ```

## 函数中使用默认参数
- 形参赋值操作方向为 **从左往右**
- 传参时赋值可以覆盖默认参数
- 函数的声明和定义都设置了默认参数，**编译系统会以声明时指定的默认参数为准**(建议设置一致)

## 函数模版 Template
- 要求：参数个数、函数实现相同，参数类型不同： template <typename T>
- 类型参数可以不止一个： template <typename T1, typename T2>

## 引用
``` C
int &b = a;
```
- **&** 在这里是 **引用声明符**，并不代表地址
- 此时b就是a，占用内存的同一个存储单元，可以理解为：**使变量b具有变量a的地址**
- C++ 中使用引用来作为函数参数
  - 指针传参可以实现将形参变量的值传回来，但是在概念上绕了一圈
- **声明一个引用类型变量，必须同时初始化**
  - 在函数参数中使用 **引用变量**，因为引用变量不是一个独立的变量，它实际就是实参，所以他不占用内存单元
  - 而且使用上相对指针传参更加直观、易读
  ``` C
  void test(Time&);     //声明
  void test(Time &t);   //定义
  ```

## 面向对象
### 类的声明与定义
- 类是对象的抽象，对象是类的具体实例
- 类是抽象的，不占用内存；对象是具体的，需要占用存储空间
- **在类的定义中，如果不指定 *成员访问限定符*：private或public，缺省是private**
  - 成员访问限定符：protected，不能被类外访问，但能被 **派生类的成员函数** 访问
  - 用 **struct** 声明的类，成员特性默认是public的
- **类class 和 结构体struct 的区别 （在C++中）**
  - [C结构体、C++结构体、C++类的区别](https://www.cnblogs.com/cthon/p/9170596.html)
  - 概念：class和struct的语法基本相同，从声明到使用，都很相似，但是struct的约束要比class多，理论上，struct能做到的class都能做到，但class能做到的stuct却不一定做的到。
  - 类型：struct是值类型，class是引用类型，因此它们具有所有值类型和引用类型之间的差异。
  ``` java
    static void Main(string[] args)
    {
        //普通变量是值类型，赋值操作时会保存两份
        //编译器会先复制strA的值，然后赋给strB，会在内存的两个地方储存值100
        int strA = 100;
        int strB = strA;

        //类是引用类型
        //赋值操作完成后，两个变量都指向同一内存地址
        MyVector vA = new MyVector();
        MyVector vB = vA;
        vA.Value = 100;
        //由于vA和vB指向同一内存地址，所以vB.Value的值也为100 
        Console.WriteLine(vA.Value + "  等于  " + vB.Value);
        vB.Value = 200;
        //同理vA.Value =vB.Value
        Console.WriteLine(vA.Value + "  等于  " + vB.Value);

        //结构体是值类型。
        //赋值操作完成后，两个结构中的结构信息一致
        //注意仅仅是"结构中的信息"一致。
        MyStruct structA = new MyStruct();
        MyStruct structB = structA; 
        structA.Value = 100;
        structB.Value = 200;
        //同理vA.Value !=vB.Value
        Console.WriteLine(structA.Value + "  不等于  " + structB.Value);
        Console.Read();
    }

    private class MyVector
    {
        public int Value { get; set; }
    }

    private struct MyStruct
    {
        public int Value;
    }
  ```
  - 效率：由于堆栈的执行效率要比堆的执行效率高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，而class来处理某个商业逻辑。
  - 关系：struct不仅能继承也能被继承 ，而且可以实现接口，不过Class可以完全扩展。内部结构有区别，struct只能添加带参的构造函数，不能使用abstract和protected等修饰符，不能初始化实例字段。

### 类的成员函数
- 私有成员函数只能被本类中的其他成员函数调用，而不能被类外调用
- 成员函数可以访问本类中任何成员private/public，可以引用在本作用域内有效的数据
- inline成员函数
  - 在类体内定义的成员函数默认是inline，无需显示声明
  - 在类体外定义的成员函数则不是，若要指定为inline函数需要显示声明
  - **在类外定义inline成员函数时，需要将类定义和成员函数定义放在同一个源文件（.c/.h）**
    - 否则会编译不过
    - 软件执行效率提高，但是不利于软件工程的信息隐蔽等问题
    - 建议仅当 类外定义的成员函数规模小调用频率高时，才设置为inline
- 定义对象时，每个对象占用的存储空间只是该对象的数据部分，不包括成员函数代码所占用的存储空间，**函数代码是存储在对象空间之外的**
  - 这个储存方式跟 **inline** 是两回事

### 对象成员的引用
- 访问对象成员的方法
  - 通过对象名和成员运算符访问对象中的成员
  - 通过指向对象的指针访问对象中的成员
    ``` C
    Time t, *p;
    p = &t;
    (*p).xxx == p->xxx == t.xxx
    ```
  - 通过对象的引用变量访问对象中的成员
    ``` C
    Time t1;
    Time &t2 = t1;
    t2.xxx == t1.xxx
    ```

### 类的封装性和信息隐蔽


- C语言中一般习惯将声明全部集中写在模块开头，但是在C++中不提倡这种做法：在C++中，声明是作为语句处理的，可以出现在程序的任何位置；用到的时候再生明反而会使程序更加清晰易读